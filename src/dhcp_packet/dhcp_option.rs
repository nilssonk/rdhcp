#[derive(Debug, PartialEq, Eq)]
pub enum DhcpOption<'a> {
    Padding(usize),
    SubnetMask,
    TimeOffset,
    Router,
    TimeServer,
    NameServer,
    DomainServer,
    LogServer,
    QuotesServer,
    LprServer,
    ImpressServer,
    RlpServer,
    Hostname,
    BootFileSize,
    MeritDumpFile,
    DomainName,
    SwapServer,
    RootPath,
    ExtensionFile,
    ForwardingOnOff,
    SourceRoutingOnOff,
    PolicyFilter,
    MaxDatagramAssembly,
    DefaultIpTtl,
    MtuTimeout,
    MtuPlateau,
    MtuInterface,
    MtuSubnet,
    BroadcastAddress,
    MaskDiscovery,
    MaskSupplier,
    RouterDiscovery,
    RouterRequest,
    StaticRoute,
    TrailerEncapsulation,
    ArpTimeout,
    EthernetEncapsulation,
    DefaultTcpTtl,
    KeepaliveTime,
    KeepaliveData,
    NisDomain,
    NisServers,
    NtpServers,
    VendorSpecificInformation,
    NetbiosName,
    NetbiosSDist,
    NetbiosNodeType,
    NetbiosScope,
    XWindowFontServer,
    XWindowDisplayManager,
    RequestedIpAddress,
    IpAddressLeaseTime,
    Overload,
    DhcpMsgType,
    DhcpServerId,
    ParameterRequestList,
    DhcpErrorMessage,
    DhcpMaxMessageSize,
    DhcpRenewalTime,
    DhcpRebindingTime,
    ClassId,
    ClientId,
    NetWareIpDomain,
    NetWareIpOption,
    NisDomainName,
    NisServerAddress,
    TftpServerName,
    BootfileName,
    HomeAgentAddress,
    SmtpServers,
    Pop3Serverss,
    NntpServers,
    WwwServers,
    FingerServers,
    IrcServers,
    StreetTalkServers,
    StdaServers,
    UserClassInformation,
    DirectoryAgentInformation,
    ServiceLocationAgentScope,
    RapidCommit,
    ClientFqdn,
    RelayAgentInformation,
    Isns,
    Removed,
    NdsServers,
    NdsTreeName,
    NdsContext,
    BcmcsControllerDomainNameList,
    BcmcsControllerIpv4Address,
    Authentication,
    ClientLastTransactionTime,
    AssociatedIp,
    ClientSystem,
    ClientNdi,
    Ldap,
    UuidGuid,
    OpenGroupUserAuth,
    GeoconfCivic,
    MagicCookie,
    PCode,
    TCode,
    Ipv6OnlyPreferred,
    Dhcpv4OverDhcpv6,
    NetinfoAddress,
    NetinfoTag,
    DhcpCaptivePortal,
    DhcpAutoConfiguration,
    NameServiceSearch,
    SubnetSelection,
    DomainSearchList,
    SipServers,
    ClasslessStaticRoute,
    CablelabsClientConfiguration,
    GeoConf,
    VendorClass,
    PxeVendorSpecific,
    EtherbootSignature,
    DocsisFullSecurityServerIpAddress,
    TftpServerIpAddress,
    KernelOptions,
    CallServerIpAddress,
    EthernetInterface,
    VendorDiscriminationString,
    RemoteStatisticsServerIpAddress,
    Ieee8021QVlanId,
    Ieee8021DLayer2Priority,
    DiffServCodePoint,
    HttpProxy,
    PanaAgent,
    V4Lost,
    CapwapAccessControllerAddresses,
    Ipv4AddressMos,
    Ipv4FqdnMos,
    SipUaConfigurationServiceDomains,
    Ipv4AddressAndsf,
    V4SztpRedirects,
    GeoLoc,
    ForcerenewNonceCapable,
    RdnssSelection,
    V4DotsRi,
    V4DotsAddress,
    TftpServerAddress,
    Etherboot,
    GrubConfigurationPathName,
    StatusCode,
    BaseTime,
    StartTimeOfState,
    QueryStartTime,
    QueryEndTime,
    DhcpState,
    DataSource,
    V4PcpServer,
    Polycom,
    MudUrlV4,
    IpTelephone,
    PacketCableAndCableHome,
    PxeLinuxMagic,
    ConfigurationFile,
    PathPrefix,
    RebootTime,
    BrAddresses6rd,
    V4AccessDomain,
    Unassigned,
    SubnetAllocation,
    VirtualSubnetSelection,
    Reserved,
    Unknown(&'a [u8]),
    End,
}

impl<'a> DhcpOption<'a> {
    fn consolidated_padding(data: &[u8]) -> Self {
        let mut length = 1;

        while length < data.len() && data[length] == 0 {
            length += 1;
        }

        Self::Padding(length)
    }

    fn try_decode_tlv(data: &'a [u8]) -> Option<Self> {
        if data.len() < 2 {
            return None;
        }

        let length = data[1] as usize;

        Some(Self::Unknown(&data[..length + 2]))
    }

    pub(crate) fn try_decode(data: &'a [u8]) -> Option<Self> {
        let tag = data[0];
        match tag {
            0 => Some(Self::consolidated_padding(data)),
            99 => Some(Self::MagicCookie),
            255 => Some(Self::End),
            _ => Self::try_decode_tlv(data),
        }
    }

    pub fn get_length(&self) -> usize {
        match self {
            Self::Padding(n) => *n,
            Self::MagicCookie => 4,
            Self::End => 1,
            Self::Unknown(data) => data.len(),
            _ => todo!(),
        }
    }
}
